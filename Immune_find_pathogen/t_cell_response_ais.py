import matplotlib

matplotlib.use('Qt5Agg')  # use Qt5 as backend, comment this line for default backend
import numpy as np
import random
from matplotlib import pyplot as plt
from Modules import Bacteria
from Modules import Chemotaxis
from Modules import DendricCells
from Modules import Immune_cells
from Modules import Inflammation
from matplotlib import animation

# Initial Variable Declaration
arena_x = 80
arena_y = 80
call_nk = True  # For Calling Initial Immune Response
type_im_cell = 1
start_itr = 0
no_iter = 250
types_bac = 2
num_bac = [10, 15]
is_alive = [[1] * i for i in num_bac]
bac_x = [[] for _ in range(types_bac)]
bac_y = [[] for _ in range(types_bac)]
bac_loc1 = [[] for _ in range(types_bac)]
exp_area_bac = [5, 8]
bac_plac = [[10, 40], [50, 60]]
int_damage = [np.array([]) for _ in range(types_bac)]
chemo = [np.array([]) for _ in range(types_bac)]
marker = ['r*', 'g*', 'y*', 'm*']
state_dc = []
w = [5, 3, 2]  # [wp, wd, ws]

# Initialization Of DC, Bacteria and Chemokines Objects
dendric = DendricCells(arena_x, arena_y)  # Dendric Object
no_dc, dc_x, dc_y = dendric.placement(0.01)

bac_pop = [Bacteria(arena_x, arena_y, num) for num in num_bac]  # Bacteria Object
pool_bac_pattern = [bin(x)[2:].rjust(4, '0') for x in range(2 ** 4)][0:8]
bac_patterns_status = dict()
for type_bac in range(types_bac):  # Bacteria pattern alocation
    bac_pop[type_bac].bac_pattern = random.choice(pool_bac_pattern)
    bac_patterns_status[bac_pop[type_bac].bac_pattern] = -1
    pool_bac_pattern.remove(bac_pop[type_bac].bac_pattern)
bac_patterns = list(bac_patterns_status.keys())
bac_chem = [Chemotaxis(arena_x, arena_y, num) for num in num_bac]  # Bacteria Chemokines Object
for type_bac in range(types_bac):  # for placement and chemo array of each bacteria
    bac_x[type_bac], bac_y[type_bac], bac_loc1[type_bac] = bac_pop[type_bac].cluster(exp_area_bac[type_bac],
                                                                                     bac_plac[
                                                                                         type_bac])  # Placemnt of bacteria
    chemo[type_bac] = bac_chem[type_bac].chemo_attractants('von_neumann', bac_x[type_bac], bac_y[type_bac], 0.125, 0.02,
                                                           0.25)  # Array updation of chemokines

# Initialization of Immune Cell
no_nk_cells = 12
imm_alive = [1] * no_nk_cells
mono_array = np.zeros([arena_x, arena_y])
print('Activated----------------------------Yes')
nk_cell = Immune_cells(arena_x, arena_y, no_nk_cells, 'nk_cell')
mac_chem = Chemotaxis(arena_x, arena_y, no_nk_cells)

type_tcells = 4
no_t_cell = 4
t_cell_alive = [1] * no_t_cell
t_cell_pop = [Immune_cells(arena_x, arena_y, no_t_cell, 'T-Cell') for _ in range(type_tcells)]  # Object of T-Cells

pool_tcell_pattern = [bin(x)[2:].rjust(4, '0') for x in range(2 ** 4)][0:8]
for type_tcell in range(type_tcells):  # Bacteria pattern alocation
    t_cell_pop[type_tcell].tcr = random.choice(pool_tcell_pattern)
    pool_tcell_pattern.remove(t_cell_pop[type_tcell].tcr)
mono_tcell = [np.zeros([arena_x, arena_y]) for _ in range(type_tcells)]
grad_tcell = [[] for _ in range(type_tcells)]
tcell_marker = ['b>', 'g<', 'y>', 'w<']
# tcell_monok = Chemotaxis(arena_x, arena_y, no_t_cell) # Object of T-Cell Monokines

# Initialization of Inflammation
measure_inflammation = [Inflammation(bacterium) for bacterium in num_bac]
bac_inflammation_pattern = {bac_patterns[i]: 0 for i in range(types_bac)}
change_inflammation = {bac_patterns[i]: 0 for i in range(types_bac)}
base_frame = np.zeros([arena_x, arena_y])
base_frame[arena_x - 20:arena_x - 5, 10:arena_y - 10] = 100


def update_board(base_frame):
    # All Changes to update the board will be made here
    global start_itr
    global call_nk
    tcellx = [[] for _ in range(type_tcells)]
    tcelly = [[] for _ in range(type_tcells)]
    mono_array = np.zeros([arena_x, arena_y])
    plt.cla()

    # Dendric Cell Activity
    dendric.scanning()  # Dendric Cell movement
    for type_bac in range(types_bac):  # Detection of pathogen and Danger signal by DC for each Population of Bacteria
        dendric.detect_pathogen(bac_loc1[type_bac], bac_pop[type_bac].bac_pattern)  # Detection of pathogen by DCs
        bac_x[type_bac], bac_y[type_bac], bac_loc1[type_bac] = bac_pop[type_bac].move('Active')  # movement of bacteria
        chemo[type_bac] = bac_chem[type_bac].chemo_attractants('von_neumann', bac_x[type_bac], bac_y[type_bac], 0.125,
                                                               0.02, 0.25)  # Chemokine generated by each bacteria
        int_damage[type_bac] = bac_pop[type_bac].internal_cellular_effect(3, 2)  # Internal damage Caused by bacteria
        # on Body Cell
    dendric.maturity_danger1(sum(int_damage))  # Detection of Danger signal by DCs
    state_dc, dc_output = dendric.commulative_maturity(w)  # Dendric self final output
    dendric.help_signal()  # Help signal generated by mature dc
    no_matured_dc = len([i for i in state_dc if i > 2])  # Calculation of Matured DC
    print('no_matured_dc--', no_matured_dc)

    # Immune Response
    if no_matured_dc > 4 and call_nk:  # Condition to call for immune response
        nk_cell.cluster(5, [40, 30])
        for type_tcell in range(type_tcells):
            t_cell_pop[type_tcell].random()  # Placement of T-Cells but in inactive state
        call_nk = False

    if not call_nk:  # Condition for the movement of Immune Cell
        # Monokine of Immune Cell
        mono_array = mac_chem.chemo_attractants('von_neumann', nk_cell.monocytes_x, nk_cell.monocytes_y, 0.125, 0.02,
                                                0.25)  # Array updation of Monokines
        grad_nk = nk_cell.gradient(sum(chemo), mono_array)  # Gradient Calculation of NK-Cells
        nk_cell.random_movementall(grad_nk)

        # Calculate Inflammation for each type of bac
        if start_itr % 10 == 0:
            for type_bac in range(types_bac):
                bac_inflammation_pattern[bac_patterns[type_bac]], change_inflammation[type_bac] = measure_inflammation[type_bac].perc_inflam(bac_pop[type_bac].num_bac)

        # Movement of T-Cells
        for type_tcell in range(type_tcells):  # Movement and priming of T-cells
            if not t_cell_pop[type_tcell].tcell_priming_status and -1 in list(
                    bac_patterns_status.values()):  # Priming of Naive T-cell
                print('Condition 2', list(bac_patterns_status.values()))
                grad_tcell[type_tcell] = t_cell_pop[type_tcell].gradient(dendric.dc_help_signal, mono_tcell[type_tcell])
                tcellx[type_tcell], tcelly[type_tcell] = t_cell_pop[type_tcell].random_movementall(
                    grad_tcell[type_tcell])
                t_cell_pop[type_tcell].bac_pattern = t_cell_pop[type_tcell].priming_tcell(dendric.dc_loc,
                                                                                          dendric.get_bac_pattern, pool_tcell_pattern)
                if t_cell_pop[type_tcell].tcell_priming_status and bac_patterns_status[
                    t_cell_pop[type_tcell].bac_pattern] == -1:  # Run once Only for each Primed T-cell and
                    print('Associated to bacteria---------------------------------------------',
                          t_cell_pop[type_tcell].bac_pattern)
                    Tcell_chemo_no = bac_patterns.index(t_cell_pop[type_tcell].bac_pattern)
                    bac_patterns_status[t_cell_pop[type_tcell].bac_pattern] = Tcell_chemo_no
            elif t_cell_pop[type_tcell].tcell_priming_status:  # Movement of Primed T-Cell
                print('Movement of T_cell')
                concern_bac_no = bac_patterns_status[t_cell_pop[type_tcell].bac_pattern]
                if start_itr % 5 == 0: t_cell_pop[type_tcell].proliferation(bac_inflammation_pattern[t_cell_pop[type_tcell].bac_pattern], change_inflammation[t_cell_pop[type_tcell].bac_pattern])
                grad_tcell[type_tcell] = t_cell_pop[type_tcell].gradient(
                    chemo[concern_bac_no], mono_tcell[type_tcell])
                tcellx[type_tcell], tcelly[type_tcell] = t_cell_pop[type_tcell].random_movementall(
                    grad_tcell[type_tcell])
                bac_pop[concern_bac_no].num_bac, bac_pop[concern_bac_no].bacteria_x, bac_pop[concern_bac_no].bacteria_y, bac_pop[
                    concern_bac_no].is_alive = t_cell_pop[type_tcell].kill_bac(bac_pop[concern_bac_no].num_bac, bac_x[concern_bac_no], bac_y[concern_bac_no],
                                                          bac_pop[concern_bac_no].is_alive)


    # Killing of Bacteria
    for type_bac in range(types_bac):
        bac_pop[type_bac].num_bac, bac_pop[type_bac].bacteria_x, bac_pop[type_bac].bacteria_y, bac_pop[
            type_bac].is_alive = nk_cell.kill_bac(bac_pop[type_bac].num_bac, bac_x[type_bac], bac_y[type_bac],
                                                  bac_pop[type_bac].is_alive)
    # Updating of all Plots
    plt.title('Maturation of DCs and Random movement of Bacteria ' + ' ' + str(start_itr))
    plt.xlabel('DCY')
    plt.ylabel('DCX')
    plt.imshow(dendric.dc_help_signal, origin='lower')
    dendric.arrayupdation()
    # Plotting data of DCs
    for i in range(3):
        plt.text(dendric.cell_y[37 + (8 * i)], dendric.cell_x[37 + (8 * i)], dendric.dc_output[37 + (8 * i)])
    start_itr += 1
    for type_bac in range(types_bac):
        bac_pop[type_bac].arrayupdation(marker[type_bac])  # Bacteria plot
    if call_nk == False:  # To avoid Error if immune Cell was not active
        nk_cell.arrayupdation('bo')  # Immune_cell Plot
        for type_tcell in range(type_tcells):
            t_cell_pop[type_tcell].arrayupdation(tcell_marker[type_tcell])
    dendric.movetocenter()  # Center movement of DC_cell
    return sum(chemo)


fig, ax = plt.subplots(subplot_kw={'xlim': [0, arena_x], 'ylim': [0, arena_y]})
fig = plt.gcf()
im = plt.imshow(base_frame, origin='lower')


def animate(i):
    im.set_data(update_board(base_frame))
    return im,


anim = animation.FuncAnimation(fig, animate, frames=no_iter, interval=500, repeat=False)
plt.show()
# anim.save('myAnimation.gif', writer='imagemagick', fps=30)